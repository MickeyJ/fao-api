"""create market integration data materialized views

Revision ID: af5464887bc8
Revises: eeb4c04f49ef
Create Date: 2025-06-12 17:14:56.231421

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from alembic_utils.pg_materialized_view import PGMaterializedView
from sqlalchemy import text as sql_text

# revision identifiers, used by Alembic.
revision: str = 'af5464887bc8'
down_revision: Union[str, None] = 'eeb4c04f49ef'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    public_price_ratios_usd = PGMaterializedView(
                schema="public",
                signature="price_ratios_usd",
                definition="WITH annual_prices AS (\n    SELECT\n        ac.id as area_id,\n        ac.area_code,\n        ac.area as country_name,\n        ic.item_code,\n        ic.item as item_name,\n        p.year,\n        AVG(p.value) as price\n    FROM prices p\n    JOIN area_codes ac ON p.area_code_id = ac.id\n    JOIN item_codes ic ON p.item_code_id = ic.id\n    JOIN elements e ON p.element_code_id = e.id\n    JOIN flags f ON p.flag_id = f.id\n    WHERE\n        e.element_code = '5532'  -- USD prices only\n        AND f.flag = 'A'         -- Official figures only\n        AND p.months_code = '7021'  -- Annual average\n    GROUP BY ac.id, ac.area_code, ac.area, ic.item_code, ic.item, p.year\n),\nprice_ratios AS (\n    SELECT\n        p1.area_id as country1_id,\n        p1.area_code as country1_code,\n        p1.country_name as country1,\n        p2.area_id as country2_id,\n        p2.area_code as country2_code,\n        p2.country_name as country2,\n        p1.item_code,\n        p1.item_name,\n        p1.year,\n        p1.price as price1,\n        p2.price as price2,\n        p1.price / NULLIF(p2.price, 0) as price_ratio\n    FROM annual_prices p1\n    JOIN annual_prices p2\n        ON p1.year = p2.year\n        AND p1.item_code = p2.item_code\n        AND p1.area_code < p2.area_code  -- Avoid duplicates\n)\nSELECT\n    country1,\n    country2,\n    country1_id,\n    country2_id,\n    country1_code,\n    country2_code,\n    item_code,\n    item_name,\n    JSON_AGG(\n        JSON_BUILD_OBJECT(\n            'year', year,\n            'price1', price1,\n            'price2', price2,\n            'ratio', ROUND(price_ratio::numeric, 3)\n        ) ORDER BY year\n    ) as time_series,\n    COUNT(*) as years_compared,\n    ROUND(AVG(price_ratio)::numeric, 3) as avg_ratio,\n    ROUND(STDDEV(price_ratio)::numeric, 3) as ratio_volatility,\n    ROUND(MIN(price_ratio)::numeric, 3) as min_ratio,\n    ROUND(MAX(price_ratio)::numeric, 3) as max_ratio,\n    CASE \n        WHEN STDDEV(price_ratio) < 0.1 THEN 'high'\n        WHEN STDDEV(price_ratio) < 0.2 THEN 'moderate'\n        WHEN STDDEV(price_ratio) < 0.3 THEN 'low'\n        ELSE 'none'\n    END as integration_level\nFROM price_ratios\nGROUP BY \n    country1, country2, \n    country1_id, country2_id, \n    country1_code, country2_code,\n    item_code, item_name",
                with_data=True
            )

    op.create_entity(public_price_ratios_usd)

    public_price_ratios_lcu = PGMaterializedView(
                schema="public",
                signature="price_ratios_lcu",
                definition="WITH annual_prices AS (\n    SELECT\n        ac.id as area_id,\n        ac.area_code,\n        ac.area as country_name,\n        ic.item_code,\n        ic.item as item_name,\n        p.year,\n        AVG(p.value) as price_lcu\n    FROM prices p\n    JOIN area_codes ac ON p.area_code_id = ac.id\n    JOIN item_codes ic ON p.item_code_id = ic.id\n    JOIN elements e ON p.element_code_id = e.id\n    JOIN flags f ON p.flag_id = f.id\n    WHERE\n        f.flag = 'A'\n        AND e.element_code = '5530'  -- LCU prices only\n        AND p.months_code = '7021'   -- Annual average\n    GROUP BY ac.id, ac.area_code, ac.area, ic.item_code, ic.item, p.year\n),\nnormalized_prices AS (\n    SELECT \n        ap.*,\n        ap.price_lcu / er.value as price\n    FROM annual_prices ap\n    INNER JOIN exchange_rate er ON \n        er.year = ap.year\n        AND er.element_code_id = (SELECT id FROM elements WHERE element_code = 'LCU')\n        AND er.months_code = '7021'\n    INNER JOIN area_codes ac_er ON\n        er.area_code_id = ac_er.id \n        AND ac_er.area_code = ap.area_code\n    WHERE er.value > 0\n),\nprice_ratios AS (\n    SELECT\n        p1.area_id as country1_id,\n        p1.area_code as country1_code,\n        p1.country_name as country1,\n        p2.area_id as country2_id,\n        p2.area_code as country2_code,\n        p2.country_name as country2,\n        p1.item_code,\n        p1.item_name,\n        p1.year,\n        p1.price as price1,  -- Now in USD\n        p2.price as price2,  -- Now in USD\n        p1.price / NULLIF(p2.price, 0) as price_ratio\n    FROM normalized_prices p1\n    JOIN normalized_prices p2\n        ON p1.year = p2.year\n        AND p1.item_code = p2.item_code\n        AND p1.area_code < p2.area_code\n)\nSELECT\n    country1,\n    country2,\n    country1_id,\n    country2_id,\n    country1_code,\n    country2_code,\n    item_code,\n    item_name,\n    JSON_AGG(\n        JSON_BUILD_OBJECT(\n            'year', year,\n            'price1', price1,\n            'price2', price2,\n            'ratio', ROUND(price_ratio::numeric, 3)\n        ) ORDER BY year\n    ) as time_series,\n    COUNT(*) as years_compared,\n    ROUND(AVG(price_ratio)::numeric, 3) as avg_ratio,\n    ROUND(STDDEV(price_ratio)::numeric, 3) as ratio_volatility,\n    ROUND(MIN(price_ratio)::numeric, 3) as min_ratio,\n    ROUND(MAX(price_ratio)::numeric, 3) as max_ratio,\n    CASE \n        WHEN STDDEV(price_ratio) < 0.1 THEN 'high'\n        WHEN STDDEV(price_ratio) < 0.2 THEN 'moderate'\n        WHEN STDDEV(price_ratio) < 0.3 THEN 'low'\n        ELSE 'none'\n    END as integration_level\nFROM price_ratios\nGROUP BY \n    country1, country2, \n    country1_id, country2_id, \n    country1_code, country2_code,\n    item_code, item_name",
                with_data=True
            )

    op.create_entity(public_price_ratios_lcu)

    public_price_details_usd = PGMaterializedView(
                schema="public",
                signature="price_details_usd",
                definition="SELECT \n    ac.id as area_id,\n    ac.area as area_name,\n    ac.area_code,\n    p.year,\n    p.value as price,\n    p.unit,\n    ic.item as item_name,\n    ic.item_code,\n    ic.id as item_id\nFROM prices p\nJOIN item_codes ic ON ic.id = p.item_code_id\nJOIN area_codes ac ON ac.id = p.area_code_id\nJOIN elements e ON e.id = p.element_code_id\nJOIN flags f ON f.id = p.flag_id\nWHERE \n    e.element_code = '5532'  -- USD prices\n    AND f.flag = 'A'         -- Official figures only\n    AND p.months_code = '7021'  -- Annual prices only\nORDER BY ac.area_code, p.year",
                with_data=True
            )

    op.create_entity(public_price_details_usd)

    public_price_details_lcu = PGMaterializedView(
                schema="public",
                signature="price_details_lcu",
                definition="SELECT \n    ac.id as area_id,\n    ac.area as area_name,\n    ac.area_code,\n    p.year,\n    p.value / er.value as price,  -- Convert LCU to USD\n    'USD' as unit,                 -- Converted to USD\n    ic.item as item_name,\n    ic.item_code,\n    ic.id as item_id\nFROM prices p\nJOIN item_codes ic ON ic.id = p.item_code_id\nJOIN area_codes ac ON ac.id = p.area_code_id\nJOIN elements e ON e.id = p.element_code_id\nJOIN flags f ON f.id = p.flag_id\n-- Join exchange rate via area_code string matching\nJOIN area_codes ac_er ON ac_er.area_code = ac.area_code\nJOIN exchange_rate er ON \n    er.area_code_id = ac_er.id\n    AND er.year = p.year\n    AND er.months_code = '7021'  -- Annual rates\n    AND er.element_code_id = (SELECT id FROM elements WHERE element_code = 'LCU')\nWHERE \n    e.element_code = '5530'  -- LCU prices\n    AND f.flag = 'A'         -- Official figures only\n    AND p.months_code = '7021'  -- Annual prices only\n    AND er.value > 0         -- Valid exchange rates\n    -- Exclude Euro countries during transition period\n    AND NOT (\n        ac.area_code IN ('11', '15', '67', '68', '79', '134', '106', '174', '203', '255', '256')\n        AND p.year BETWEEN 1999 AND 2001\n    )\nORDER BY ac.area_code, p.year",
                with_data=True
            )

    op.create_entity(public_price_details_lcu)

    public_item_stats_lcu = PGMaterializedView(
                schema="public",
                signature="item_stats_lcu",
                definition="SELECT \n    ic.id,\n    ic.item as name,\n    ic.item_code,\n    ic.item_code_cpc as cpc_code,\n    COUNT(DISTINCT p.id) as price_points,\n    COUNT(DISTINCT p.area_code_id) as countries_with_data,\n    COUNT(DISTINCT p.year) as years_with_data,\n    MIN(p.year) as earliest_year,\n    MAX(p.year) as latest_year,\n    -- Average data points per country (indicates data density)\n    (COUNT(p.id)::numeric / COUNT(DISTINCT p.area_code_id)) as avg_points_per_country\nFROM item_codes ic\nJOIN prices p ON ic.id = p.item_code_id\nJOIN elements e ON e.id = p.element_code_id\nJOIN flags f ON f.id = p.flag_id\nWHERE \n    e.element_code = '5530'  -- LCU prices\n    AND ic.source_dataset = 'prices'\n    AND f.flag = 'A'\n    AND p.year >= 1990\nGROUP BY ic.id, ic.item, ic.item_code, ic.item_code_cpc\nHAVING \n    COUNT(DISTINCT p.area_code_id) >= 10  -- At least 10 countries\n    AND COUNT(DISTINCT p.year) >= 10       -- At least 5 years of data\nORDER BY \n    COUNT(DISTINCT p.area_code_id) DESC,  -- Most countries first\n    COUNT(DISTINCT p.year) DESC,          -- Then most years\n    COUNT(p.id) DESC;                     -- Then most data points",
                with_data=True
            )

    op.create_entity(public_item_stats_lcu)

    public_item_stats_usd = PGMaterializedView(
                schema="public",
                signature="item_stats_usd",
                definition="SELECT \n    ic.id,\n    ic.item as name,\n    ic.item_code,\n    ic.item_code_cpc as cpc_code,\n    COUNT(DISTINCT p.id) as price_points,\n    COUNT(DISTINCT p.area_code_id) as countries_with_data,\n    COUNT(DISTINCT p.year) as years_with_data,\n    MIN(p.year) as earliest_year,\n    MAX(p.year) as latest_year,\n    -- Average data points per country (indicates data density)\n    (COUNT(p.id)::numeric / COUNT(DISTINCT p.area_code_id)) as avg_points_per_country\nFROM item_codes ic\nJOIN prices p ON ic.id = p.item_code_id\nJOIN elements e ON e.id = p.element_code_id\nJOIN flags f ON f.id = p.flag_id\nWHERE \n    e.element_code = '5532'  -- USD prices\n    AND ic.source_dataset = 'prices'\n    AND f.flag = 'A'\n    AND p.year >= 1990\nGROUP BY ic.id, ic.item, ic.item_code, ic.item_code_cpc\nHAVING \n    COUNT(DISTINCT p.area_code_id) >= 10  -- At least 10 countries\n    AND COUNT(DISTINCT p.year) >= 10       -- At least 5 years of data\nORDER BY \n    COUNT(DISTINCT p.area_code_id) DESC,  -- Most countries first\n    COUNT(DISTINCT p.year) DESC,          -- Then most years\n    COUNT(p.id) DESC;                     -- Then most data points",
                with_data=True
            )

    op.create_entity(public_item_stats_usd)

    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    public_item_stats_usd = PGMaterializedView(
                schema="public",
                signature="item_stats_usd",
                definition="SELECT \n    ic.id,\n    ic.item as name,\n    ic.item_code,\n    ic.item_code_cpc as cpc_code,\n    COUNT(DISTINCT p.id) as price_points,\n    COUNT(DISTINCT p.area_code_id) as countries_with_data,\n    COUNT(DISTINCT p.year) as years_with_data,\n    MIN(p.year) as earliest_year,\n    MAX(p.year) as latest_year,\n    -- Average data points per country (indicates data density)\n    (COUNT(p.id)::numeric / COUNT(DISTINCT p.area_code_id)) as avg_points_per_country\nFROM item_codes ic\nJOIN prices p ON ic.id = p.item_code_id\nJOIN elements e ON e.id = p.element_code_id\nJOIN flags f ON f.id = p.flag_id\nWHERE \n    e.element_code = '5532'  -- USD prices\n    AND ic.source_dataset = 'prices'\n    AND f.flag = 'A'\n    AND p.year >= 1990\nGROUP BY ic.id, ic.item, ic.item_code, ic.item_code_cpc\nHAVING \n    COUNT(DISTINCT p.area_code_id) >= 10  -- At least 10 countries\n    AND COUNT(DISTINCT p.year) >= 10       -- At least 5 years of data\nORDER BY \n    COUNT(DISTINCT p.area_code_id) DESC,  -- Most countries first\n    COUNT(DISTINCT p.year) DESC,          -- Then most years\n    COUNT(p.id) DESC;                     -- Then most data points",
                with_data=True
            )

    op.drop_entity(public_item_stats_usd)

    public_item_stats_lcu = PGMaterializedView(
                schema="public",
                signature="item_stats_lcu",
                definition="SELECT \n    ic.id,\n    ic.item as name,\n    ic.item_code,\n    ic.item_code_cpc as cpc_code,\n    COUNT(DISTINCT p.id) as price_points,\n    COUNT(DISTINCT p.area_code_id) as countries_with_data,\n    COUNT(DISTINCT p.year) as years_with_data,\n    MIN(p.year) as earliest_year,\n    MAX(p.year) as latest_year,\n    -- Average data points per country (indicates data density)\n    (COUNT(p.id)::numeric / COUNT(DISTINCT p.area_code_id)) as avg_points_per_country\nFROM item_codes ic\nJOIN prices p ON ic.id = p.item_code_id\nJOIN elements e ON e.id = p.element_code_id\nJOIN flags f ON f.id = p.flag_id\nWHERE \n    e.element_code = '5530'  -- LCU prices\n    AND ic.source_dataset = 'prices'\n    AND f.flag = 'A'\n    AND p.year >= 1990\nGROUP BY ic.id, ic.item, ic.item_code, ic.item_code_cpc\nHAVING \n    COUNT(DISTINCT p.area_code_id) >= 10  -- At least 10 countries\n    AND COUNT(DISTINCT p.year) >= 10       -- At least 5 years of data\nORDER BY \n    COUNT(DISTINCT p.area_code_id) DESC,  -- Most countries first\n    COUNT(DISTINCT p.year) DESC,          -- Then most years\n    COUNT(p.id) DESC;                     -- Then most data points",
                with_data=True
            )

    op.drop_entity(public_item_stats_lcu)

    public_price_details_lcu = PGMaterializedView(
                schema="public",
                signature="price_details_lcu",
                definition="SELECT \n    ac.id as area_id,\n    ac.area as area_name,\n    ac.area_code,\n    p.year,\n    p.value / er.value as price,  -- Convert LCU to USD\n    'USD' as unit,                 -- Converted to USD\n    ic.item as item_name,\n    ic.item_code,\n    ic.id as item_id\nFROM prices p\nJOIN item_codes ic ON ic.id = p.item_code_id\nJOIN area_codes ac ON ac.id = p.area_code_id\nJOIN elements e ON e.id = p.element_code_id\nJOIN flags f ON f.id = p.flag_id\n-- Join exchange rate via area_code string matching\nJOIN area_codes ac_er ON ac_er.area_code = ac.area_code\nJOIN exchange_rate er ON \n    er.area_code_id = ac_er.id\n    AND er.year = p.year\n    AND er.months_code = '7021'  -- Annual rates\n    AND er.element_code_id = (SELECT id FROM elements WHERE element_code = 'LCU')\nWHERE \n    e.element_code = '5530'  -- LCU prices\n    AND f.flag = 'A'         -- Official figures only\n    AND p.months_code = '7021'  -- Annual prices only\n    AND er.value > 0         -- Valid exchange rates\n    -- Exclude Euro countries during transition period\n    AND NOT (\n        ac.area_code IN ('11', '15', '67', '68', '79', '134', '106', '174', '203', '255', '256')\n        AND p.year BETWEEN 1999 AND 2001\n    )\nORDER BY ac.area_code, p.year",
                with_data=True
            )

    op.drop_entity(public_price_details_lcu)

    public_price_details_usd = PGMaterializedView(
                schema="public",
                signature="price_details_usd",
                definition="SELECT \n    ac.id as area_id,\n    ac.area as area_name,\n    ac.area_code,\n    p.year,\n    p.value as price,\n    p.unit,\n    ic.item as item_name,\n    ic.item_code,\n    ic.id as item_id\nFROM prices p\nJOIN item_codes ic ON ic.id = p.item_code_id\nJOIN area_codes ac ON ac.id = p.area_code_id\nJOIN elements e ON e.id = p.element_code_id\nJOIN flags f ON f.id = p.flag_id\nWHERE \n    e.element_code = '5532'  -- USD prices\n    AND f.flag = 'A'         -- Official figures only\n    AND p.months_code = '7021'  -- Annual prices only\nORDER BY ac.area_code, p.year",
                with_data=True
            )

    op.drop_entity(public_price_details_usd)

    public_price_ratios_lcu = PGMaterializedView(
                schema="public",
                signature="price_ratios_lcu",
                definition="WITH annual_prices AS (\n    SELECT\n        ac.id as area_id,\n        ac.area_code,\n        ac.area as country_name,\n        ic.item_code,\n        ic.item as item_name,\n        p.year,\n        AVG(p.value) as price_lcu\n    FROM prices p\n    JOIN area_codes ac ON p.area_code_id = ac.id\n    JOIN item_codes ic ON p.item_code_id = ic.id\n    JOIN elements e ON p.element_code_id = e.id\n    JOIN flags f ON p.flag_id = f.id\n    WHERE\n        f.flag = 'A'\n        AND e.element_code = '5530'  -- LCU prices only\n        AND p.months_code = '7021'   -- Annual average\n    GROUP BY ac.id, ac.area_code, ac.area, ic.item_code, ic.item, p.year\n),\nnormalized_prices AS (\n    SELECT \n        ap.*,\n        ap.price_lcu / er.value as price\n    FROM annual_prices ap\n    INNER JOIN exchange_rate er ON \n        er.year = ap.year\n        AND er.element_code_id = (SELECT id FROM elements WHERE element_code = 'LCU')\n        AND er.months_code = '7021'\n    INNER JOIN area_codes ac_er ON\n        er.area_code_id = ac_er.id \n        AND ac_er.area_code = ap.area_code\n    WHERE er.value > 0\n),\nprice_ratios AS (\n    SELECT\n        p1.area_id as country1_id,\n        p1.area_code as country1_code,\n        p1.country_name as country1,\n        p2.area_id as country2_id,\n        p2.area_code as country2_code,\n        p2.country_name as country2,\n        p1.item_code,\n        p1.item_name,\n        p1.year,\n        p1.price as price1,  -- Now in USD\n        p2.price as price2,  -- Now in USD\n        p1.price / NULLIF(p2.price, 0) as price_ratio\n    FROM normalized_prices p1\n    JOIN normalized_prices p2\n        ON p1.year = p2.year\n        AND p1.item_code = p2.item_code\n        AND p1.area_code < p2.area_code\n)\nSELECT\n    country1,\n    country2,\n    country1_id,\n    country2_id,\n    country1_code,\n    country2_code,\n    item_code,\n    item_name,\n    JSON_AGG(\n        JSON_BUILD_OBJECT(\n            'year', year,\n            'price1', price1,\n            'price2', price2,\n            'ratio', ROUND(price_ratio::numeric, 3)\n        ) ORDER BY year\n    ) as time_series,\n    COUNT(*) as years_compared,\n    ROUND(AVG(price_ratio)::numeric, 3) as avg_ratio,\n    ROUND(STDDEV(price_ratio)::numeric, 3) as ratio_volatility,\n    ROUND(MIN(price_ratio)::numeric, 3) as min_ratio,\n    ROUND(MAX(price_ratio)::numeric, 3) as max_ratio,\n    CASE \n        WHEN STDDEV(price_ratio) < 0.1 THEN 'high'\n        WHEN STDDEV(price_ratio) < 0.2 THEN 'moderate'\n        WHEN STDDEV(price_ratio) < 0.3 THEN 'low'\n        ELSE 'none'\n    END as integration_level\nFROM price_ratios\nGROUP BY \n    country1, country2, \n    country1_id, country2_id, \n    country1_code, country2_code,\n    item_code, item_name",
                with_data=True
            )

    op.drop_entity(public_price_ratios_lcu)

    public_price_ratios_usd = PGMaterializedView(
                schema="public",
                signature="price_ratios_usd",
                definition="WITH annual_prices AS (\n    SELECT\n        ac.id as area_id,\n        ac.area_code,\n        ac.area as country_name,\n        ic.item_code,\n        ic.item as item_name,\n        p.year,\n        AVG(p.value) as price\n    FROM prices p\n    JOIN area_codes ac ON p.area_code_id = ac.id\n    JOIN item_codes ic ON p.item_code_id = ic.id\n    JOIN elements e ON p.element_code_id = e.id\n    JOIN flags f ON p.flag_id = f.id\n    WHERE\n        e.element_code = '5532'  -- USD prices only\n        AND f.flag = 'A'         -- Official figures only\n        AND p.months_code = '7021'  -- Annual average\n    GROUP BY ac.id, ac.area_code, ac.area, ic.item_code, ic.item, p.year\n),\nprice_ratios AS (\n    SELECT\n        p1.area_id as country1_id,\n        p1.area_code as country1_code,\n        p1.country_name as country1,\n        p2.area_id as country2_id,\n        p2.area_code as country2_code,\n        p2.country_name as country2,\n        p1.item_code,\n        p1.item_name,\n        p1.year,\n        p1.price as price1,\n        p2.price as price2,\n        p1.price / NULLIF(p2.price, 0) as price_ratio\n    FROM annual_prices p1\n    JOIN annual_prices p2\n        ON p1.year = p2.year\n        AND p1.item_code = p2.item_code\n        AND p1.area_code < p2.area_code  -- Avoid duplicates\n)\nSELECT\n    country1,\n    country2,\n    country1_id,\n    country2_id,\n    country1_code,\n    country2_code,\n    item_code,\n    item_name,\n    JSON_AGG(\n        JSON_BUILD_OBJECT(\n            'year', year,\n            'price1', price1,\n            'price2', price2,\n            'ratio', ROUND(price_ratio::numeric, 3)\n        ) ORDER BY year\n    ) as time_series,\n    COUNT(*) as years_compared,\n    ROUND(AVG(price_ratio)::numeric, 3) as avg_ratio,\n    ROUND(STDDEV(price_ratio)::numeric, 3) as ratio_volatility,\n    ROUND(MIN(price_ratio)::numeric, 3) as min_ratio,\n    ROUND(MAX(price_ratio)::numeric, 3) as max_ratio,\n    CASE \n        WHEN STDDEV(price_ratio) < 0.1 THEN 'high'\n        WHEN STDDEV(price_ratio) < 0.2 THEN 'moderate'\n        WHEN STDDEV(price_ratio) < 0.3 THEN 'low'\n        ELSE 'none'\n    END as integration_level\nFROM price_ratios\nGROUP BY \n    country1, country2, \n    country1_id, country2_id, \n    country1_code, country2_code,\n    item_code, item_name",
                with_data=True
            )

    op.drop_entity(public_price_ratios_usd)

    # ### end Alembic commands ###
